import {__decorate} from 'tslib'
import {Service} from '@roots/bud-framework'
import MiniCssExtractPlugin from 'mini-css-extract-plugin'
import {Loader} from '../Loader'
import {Rule} from '../Rule'
import {Item} from '../Item'
import {config} from './config'
import {boundMethod as bind} from 'autobind-decorator'
import {posix} from 'path'
class Build extends Service {
  constructor() {
    super(...arguments)
    this.name = '@roots/bud-build'
    this.loaders = {}
    this.rules = {}
    this.items = {}
  }
  get config() {
    return this.app.hooks.filter('build')
  }
  register() {
    this.app.hooks.on('before', () => this.app)
    this.app.hooks.on('after', () => this.config)
    this.loaders = {
      css: new Loader(require.resolve('css-loader')),
      style: new Loader(require.resolve('style-loader')),
      minicss: new Loader(MiniCssExtractPlugin.loader),
      file: new Loader(require.resolve('file-loader')),
      raw: new Loader(require.resolve('raw-loader')),
      url: new Loader(require.resolve('url-loader')),
      'resolve-url': new Loader(
        require.resolve('resolve-url-loader'),
      ),
    }
    this.items = {
      css: new Item({
        loader: ({build}) => build.loaders.css,
        options: ({hooks}) => {
          var _a
          return {
            sourceMap:
              (_a = hooks.filter('build/devtool')) !== null &&
              _a !== void 0
                ? _a
                : false,
            importLoaders: 1,
          }
        },
      }),
      style: new Item({
        loader: ({build}) => build.loaders.style,
      }),
      minicss: new Item({
        loader: ({build}) => build.loaders.minicss,
        options: app => ({
          publicPath: posix.normalize(
            posix.dirname(
              posix.relative(
                app.path('project'),
                app.path('src'),
              ),
            ),
          ),
        }),
      }),
      ['raw']: new Item({
        loader: ({build}) => build.loaders.raw,
      }),
      ['file']: new Item({
        loader: ({build}) => build.loaders.file,
        options: ({store}) => ({
          name: `${
            store.isTrue('hash')
              ? store.get('hashFormat')
              : store.get('fileFormat')
          }.[ext]`,
        }),
      }),
      ['asset']: new Item({
        loader: ({build}) => build.loaders.file,
        options: ({store}) => ({
          name: `assets/${
            store.isTrue('hash')
              ? store.get('hashFormat')
              : store.get('fileFormat')
          }.[ext]`,
        }),
      }),
      ['resolve-url']: new Item({
        loader: ({build}) => build.loaders['resolve-url'],
        options: ({path, hooks}) => {
          var _a
          return {
            root: path('src'),
            sourceMap:
              (_a = hooks.filter('build/devtool')) !== null &&
              _a !== void 0
                ? _a
                : false,
          }
        },
      }),
    }
    this.rules = {
      css: new Rule({
        test: ({store}) => store.get('patterns.css'),
        exclude: ({store}) => store.get('patterns.modules'),
        use: ({isProduction, build}) => [
          isProduction ? build.items.minicss : build.items.style,
          build.items.css,
        ],
      }),
      js: new Rule({
        test: ({store}) => store.get('patterns.js'),
        exclude: ({store}) => store.get('patterns.modules'),
        use: ({build}) => [build.items['raw']],
      }),
      image: new Rule({
        test: ({store}) => store.get('patterns.image'),
        exclude: ({store}) => store.get('patterns.modules'),
        use: ({build}) => [build.items['asset']],
      }),
      font: new Rule({
        test: ({store}) => store.get('patterns.font'),
        exclude: ({store}) => store.get('patterns.modules'),
        use: ({build}) => [build.items['resolve-url']],
      }),
      svg: new Rule({
        test: ({store}) => store.get('patterns.svg'),
        exclude: ({store}) => store.get('patterns.modules'),
        type: 'asset/resource',
      }),
      html: new Rule({
        test: ({store}) => store.get('patterns.html'),
        exclude: ({store}) => store.get('patterns.modules'),
        use: ({build}) => [build.items['raw']],
      }),
    }
    config.bind(this.app)()
  }
}
__decorate([bind], Build.prototype, 'register', null)
export {Build}
//# sourceMappingURL=index.js.map
