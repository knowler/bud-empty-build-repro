import {sync} from 'globby'
import {isArray, isString} from 'lodash'
export const entry = function (...args) {
  /**
   * Ducktype entrypoint to determine if it was called like
   * entry(name, ...assets) or entry({[name]: ...assets})
   */
  const isSingleEntry = isString(args[0]) && args.length > 1
  /**
   * Cast single asset calls to keyed obj
   */
  const entrypoints = isSingleEntry
    ? [{[args[0]]: args[1]}]
    : args
  /**
   * Make the entrypoints and return the framework
   * to the builder
   */
  return makeEntrypoints.bind(this)(...entrypoints)
}
/**
 * Make entrypoints
 */
function makeEntrypoints(entry) {
  this.hooks.on('build/entry', existant => {
    return Object.assign(
      Object.assign({}, existant),
      Object.entries(entry).reduce(
        (entrypoints, [name, entry]) => {
          var _a
          /**
           * Normalize entrypoint
           */
          entry = isString(entry) ? {import: [entry]} : entry
          entry = isArray(entry) ? {import: entry} : entry
          return Object.assign(Object.assign({}, entrypoints), {
            [name]: Object.assign(
              Object.assign(
                {},
                (_a = entrypoints[name]) !== null &&
                  _a !== void 0
                  ? _a
                  : {},
              ),
              getAssets.bind(this)(name, entry),
            ),
          })
        },
        {},
      ),
    )
  })
  return this
}
/**
 * Normalize Task
 */
const normalize = assets => (isArray(assets) ? assets : [assets])
/**
 * Get entrypoint assets
 */
function getAssets(name, entry) {
  /**
   * If the supplied strings are ALL directly resolvable, use them.
   * Otherwise, treat as glob.
   */
  entry.import = normalize(entry.import).reduce(
    (resolvable, asset) => {
      if (!resolvable) return false
      try {
        require.resolve(asset)
        return true
      } catch (_a) {
        return false
      }
    },
    true,
  )
    ? entry.import
    : sync(entry.import, {
        cwd: this.path('src'),
        expandDirectories: true,
      })
  /**
   * Invalid entrypoint
   */
  if (!(entry.import.length > 0)) {
    console.error('Assets not found')
    console.error(
      `entrypoint ${name} did not return any results. Make sure these assets are available on disk.\n`,
    )
    process.exit()
  }
  /**
   * Entrypoints will always generate a JS file even when it is
   * just boilerplate (css only entrypoint)
   */
  if (isCssOnlyEntrypoint(entry.import)) {
    this.extensions
      .get('ignore-emit-webpack-plugin')
      .set('options', options => {
        var _a
        return {
          ignore: [
            ...((_a = options.ignore) !== null && _a !== void 0
              ? _a
              : []),
            name.concat('.js'),
          ],
        }
      })
  }
  return entry
}
/**
 * Return true if entrypoint is comprised of nothing but css files.
 *
 * @webpack5 this is no longer necessary
 */
function isCssOnlyEntrypoint(assets) {
  const getType = file => file.split('.').pop()
  const notCss = file => getType(file) !== 'css'
  const cssOnly = entry => {
    var _a
    return (
      ((_a = entry.filter(f => notCss(f))) === null ||
      _a === void 0
        ? void 0
        : _a.length) == 0
    )
  }
  return cssOnly(assets)
}
//# sourceMappingURL=entry.js.map
