'use strict'
Object.defineProperty(exports, '__esModule', {value: true})
const tslib_1 = require('tslib')
const bud_framework_1 = require('@roots/bud-framework')
const webpack_1 = tslib_1.__importDefault(require('webpack'))
const lodash_1 = require('lodash')
const autobind_decorator_1 = require('autobind-decorator')
class default_1 extends bud_framework_1.Service {
  constructor() {
    super(...arguments)
    this.name = '@roots/bud-compiler'
    this.isCompiled = false
    this.statsOptions = {
      all: false,
      version: true,
      hash: true,
      timings: true,
      modules: false,
      moduleAssets: false,
      builtAt: false,
      assets: true,
      chunks: false,
      children: false,
      errors: true,
      env: true,
      entrypoints: true,
      colors: true,
    }
    this.errors = []
  }
  get instance() {
    return this._instance
  }
  set instance(instance) {
    this._instance = instance
  }
  compile(config, cb) {
    if (this.isCompiled) {
      return this.instance
    }
    this.app.hooks.filter('before')
    this.instance = webpack_1.default(
      config,
      cb !== null && cb !== void 0 ? cb : null,
    )
    this.isCompiled = true
    return this.instance
  }
  callback(...args) {
    var _a
    /**
     * production mode callback takes two parameters (webpack err and stats)
     * however, the done hook used in development just takes one (stats)
     *
     * here we parse the callback args so that we dont have to
     * duplicate the callback.
     */
    const [err, stats] =
      args.length > 1 ? args : [null, args.pop()]
    this.app.when(!lodash_1.isNull(err), () => {
      this.app.error(err, 'Webpack error (pre-compile)')
      process.exit()
    })
    if (!stats) return
    stats.hasErrors() &&
      console.error(
        (_a =
          stats === null || stats === void 0
            ? void 0
            : stats.errors) === null || _a === void 0
          ? void 0
          : _a.toString(this.statsOptions),
      )
    console.log(
      stats === null || stats === void 0
        ? void 0
        : stats.toString(this.statsOptions),
    )
  }
}
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  default_1.prototype,
  'compile',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  default_1.prototype,
  'callback',
  null,
)
exports.default = default_1
//# sourceMappingURL=index.js.map
