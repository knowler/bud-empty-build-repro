import {__decorate} from 'tslib'
import {Container} from '@roots/container'
import {Store} from '../Store'
import {isFunction} from 'lodash'
import {join} from 'path'
import {boundMethod as bind} from 'autobind-decorator'
class Framework {
  constructor(config) {
    this.name = 'bud'
    this.store = new Store(this.get).setStore(
      config !== null && config !== void 0 ? config : {},
    )
  }
  get services() {
    return this._services
  }
  set services(services) {
    this._services = services
  }
  get mode() {
    return this._mode
  }
  set mode(mode) {
    this._mode = mode
  }
  get isProduction() {
    return this.mode === 'production'
  }
  get isDevelopment() {
    return this.mode === 'development'
  }
  access(value) {
    return isFunction(value) ? value(this) : value
  }
  container(repository) {
    return new Container(
      repository !== null && repository !== void 0
        ? repository
        : {},
    )
  }
  get() {
    return this
  }
  getInstance(key) {
    return this._instance.get(key)
  }
  setInstance(key, app) {
    Object.assign(this, {
      _instance: {
        [key]: app,
      },
    })
  }
  bootstrap(services) {
    this.services = this.container(services)
    this.services.getEntries().map(([key, Instance]) => {
      this[key] = new Instance(this.get)
    })
    return this
  }
  lifecycle() {
    const events = [
      'bootstrap',
      'bootstrapped',
      'register',
      'registered',
      'boot',
      'booted',
    ]
    events.forEach(event => {
      this.services.getKeys().forEach(serviceName => {
        const service = this[serviceName]
        service && service[event] && service[event](this)
      })
    })
    return this
  }
  path(key, path) {
    return join(
      ...[
        key !== 'project'
          ? this.hooks.filter('location/project')
          : false,
        this.hooks.filter(`location/${key}`),
        path !== null && path !== void 0 ? path : false,
      ].filter(Boolean),
    )
  }
  pipe(fns, value) {
    return (value = fns.reduce((val, fn) => {
      return fn(val)
    }, value))
  }
  sequence(fns) {
    fns.reduce((_val, fn) => {
      return fn.bind(this)(this)
    }, this)
    return this
  }
  when(test, trueCase, falseCase) {
    this.access(test)
      ? trueCase && isFunction(trueCase) && trueCase(this)
      : falseCase && isFunction(falseCase) && falseCase(this)
    return this
  }
  log(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .log(message, optionalArgs)
  }
  info(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .info(message, optionalArgs)
  }
  warn(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .warn(message, optionalArgs)
  }
  debug(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .debug(message, optionalArgs)
  }
  error(message, title) {
    const instance = this.dashboard.renderError(message, title)
    setTimeout(instance.quit, 2000)
  }
}
__decorate([bind], Framework.prototype, 'get', null)
__decorate([bind], Framework.prototype, 'getInstance', null)
__decorate([bind], Framework.prototype, 'setInstance', null)
__decorate([bind], Framework.prototype, 'bootstrap', null)
__decorate([bind], Framework.prototype, 'lifecycle', null)
__decorate([bind], Framework.prototype, 'path', null)
__decorate([bind], Framework.prototype, 'pipe', null)
__decorate([bind], Framework.prototype, 'sequence', null)
__decorate([bind], Framework.prototype, 'when', null)
__decorate([bind], Framework.prototype, 'log', null)
__decorate([bind], Framework.prototype, 'info', null)
__decorate([bind], Framework.prototype, 'warn', null)
__decorate([bind], Framework.prototype, 'debug', null)
__decorate([bind], Framework.prototype, 'error', null)
export {Framework}
//# sourceMappingURL=index.js.map
