'use strict'
Object.defineProperty(exports, '__esModule', {value: true})
exports.Framework = void 0
const tslib_1 = require('tslib')
const container_1 = require('@roots/container')
const Store_1 = require('../Store')
const lodash_1 = require('lodash')
const path_1 = require('path')
const autobind_decorator_1 = require('autobind-decorator')
class Framework {
  constructor(config) {
    this.name = 'bud'
    this.store = new Store_1.Store(this.get).setStore(
      config !== null && config !== void 0 ? config : {},
    )
  }
  get services() {
    return this._services
  }
  set services(services) {
    this._services = services
  }
  get mode() {
    return this._mode
  }
  set mode(mode) {
    this._mode = mode
  }
  get isProduction() {
    return this.mode === 'production'
  }
  get isDevelopment() {
    return this.mode === 'development'
  }
  access(value) {
    return lodash_1.isFunction(value) ? value(this) : value
  }
  container(repository) {
    return new container_1.Container(
      repository !== null && repository !== void 0
        ? repository
        : {},
    )
  }
  get() {
    return this
  }
  getInstance(key) {
    return this._instance.get(key)
  }
  setInstance(key, app) {
    Object.assign(this, {
      _instance: {
        [key]: app,
      },
    })
  }
  bootstrap(services) {
    this.services = this.container(services)
    this.services.getEntries().map(([key, Instance]) => {
      this[key] = new Instance(this.get)
    })
    return this
  }
  lifecycle() {
    const events = [
      'bootstrap',
      'bootstrapped',
      'register',
      'registered',
      'boot',
      'booted',
    ]
    events.forEach(event => {
      this.services.getKeys().forEach(serviceName => {
        const service = this[serviceName]
        service && service[event] && service[event](this)
      })
    })
    return this
  }
  path(key, path) {
    return path_1.join(
      ...[
        key !== 'project'
          ? this.hooks.filter('location/project')
          : false,
        this.hooks.filter(`location/${key}`),
        path !== null && path !== void 0 ? path : false,
      ].filter(Boolean),
    )
  }
  pipe(fns, value) {
    return (value = fns.reduce((val, fn) => {
      return fn(val)
    }, value))
  }
  sequence(fns) {
    fns.reduce((_val, fn) => {
      return fn.bind(this)(this)
    }, this)
    return this
  }
  when(test, trueCase, falseCase) {
    this.access(test)
      ? trueCase &&
        lodash_1.isFunction(trueCase) &&
        trueCase(this)
      : falseCase &&
        lodash_1.isFunction(falseCase) &&
        falseCase(this)
    return this
  }
  log(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .log(message, optionalArgs)
  }
  info(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .info(message, optionalArgs)
  }
  warn(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .warn(message, optionalArgs)
  }
  debug(message, ...optionalArgs) {
    this.logger.instance
      .scope(this.name)
      .debug(message, optionalArgs)
  }
  error(message, title) {
    const instance = this.dashboard.renderError(message, title)
    setTimeout(instance.quit, 2000)
  }
}
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'get',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'getInstance',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'setInstance',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'bootstrap',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'lifecycle',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'path',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'pipe',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'sequence',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'when',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'log',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'info',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'warn',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'debug',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  Framework.prototype,
  'error',
  null,
)
exports.Framework = Framework
//# sourceMappingURL=index.js.map
