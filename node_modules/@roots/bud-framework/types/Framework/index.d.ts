import { Api } from '../Api';
import { Build } from '../Build';
import { Cache } from '../Cache';
import { Compiler } from '../Compiler';
import { Container } from '@roots/container';
import { Dashboard } from '../Dashboard';
import { Dependencies } from '../Dependencies';
import { Discovery } from '../Discovery';
import { Disk } from '../Disk';
import { Env } from '../Env';
import { Extensions } from '../Extensions';
import { Hooks } from '../Hooks';
import { Item } from '../Build/Item';
import { Loader } from '../Build/Loader';
import { Logger } from '../Logger';
import { Mode } from '../Mode';
import { Module } from '../Extensions/Module';
import { Rule } from '../Build/Rule';
import { Server } from '../Server';
import { Service, Bootstrapper } from '../Service';
import { Store } from '../Store';
interface Framework {
    /**
     * Application name
     * @default 'bud'
     */
    name: string;
    /**
     * Multi-compiler instances
     * @note multi-compiler api is experimental
     */
    instance: Container<Framework>;
    /**
     * API service
     */
    api: Api;
    /**
     * Build service
     */
    build: Build;
    /**
     * Cache service
     */
    cache: Cache;
    /**
     * Compiler service
     */
    compiler: Compiler;
    /**
     * Dashboard service
     */
    dashboard: Dashboard;
    /**
     * Dependencies service
     */
    dependencies: Dependencies;
    /**
     * Discovery service
     */
    discovery: Discovery;
    /**
     * Disk service
     */
    disk: Disk;
    /**
     * Envvar service
     */
    env: Env;
    /**
     * Extensions service
     */
    extensions: Extensions;
    /**
     * Hooks service
     */
    hooks: Hooks;
    /**
     * Logger service
     */
    logger: Logger;
    /**
     * Dev server service
     */
    server: Server;
    /**
     * Key Value store service
     */
    store: Store;
    /**
     * app.access
     *
     * If a value is a function it will call that
     * function and return the result.
     *
     * If the value is not a function it will return its value.
     *
     * ```js
     * const isAFunction = (option) => `option value: ${option}`
     * const isAValue = 'option value: true'
     *
     * access(isAFunction, true)
     * // => `option value: true`
     *
     * access(isAValue)
     * // => `option value: true`
     * ```
     */
    access<I = any>(value: ((app: this) => I) | I): I;
    /**
     * app.container
     */
    container(repository?: Container['repository']): Container;
    /**
     * app.get
     */
    get(): Framework;
    /**
     * app.getInstance
     * @note multi-compiler api is experimental
     */
    getInstance(key: string): Framework;
    /**
     * app.setInstance
     * @note multi-compiler api is experimental
     */
    setInstance(key: string, framework: Framework): void;
    /**
     * app.bootstrap
     */
    bootstrap(services: {
        [key: string]: new (app: any) => Service | Bootstrapper;
    }): Framework;
    /**
     * app.lifecycle
     */
    lifecycle(): Framework;
    /**
     * app.path
     */
    path(key: `${keyof Hooks.Locale.Definitions & string}`, path?: string): string;
    /**
     * app.pipe
     */
    pipe<I = any, R = any>(fns: CallableFunction[], value: I): R;
    /**
     * app.sequence
     */
    sequence(fns: Array<(app: Framework) => any>): Framework;
    /**
     * app.when
     */
    when(test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;
    /**
     * log a message
     */
    log(message?: any, ...optionalArgs: any[]): void;
    /**
     * log (log level: warn)
     */
    warn(message?: any, ...optionalArgs: any[]): void;
    /**
     * log (log level: info)
     */
    info(message?: any, ...optionalArgs: any[]): void;
    /**
     * log (log level: debug)
     */
    debug(message?: any, ...optionalArgs: any[]): void;
    /**
     * log (log level: error)
     */
    error(message: any, title: string): void;
}
declare namespace Framework {
    interface Extensions {
        [key: string]: Module;
    }
    interface Rules {
        [key: string]: Rule;
    }
    interface Items {
        [key: string]: Item;
    }
    interface Loaders {
        [key: string]: Loader;
    }
}
declare abstract class Framework {
    name: string;
    protected _services: Container<Service>;
    protected _instance: Container<this>;
    protected _mode: Mode;
    api: Api;
    build: Build;
    cache: Cache;
    compiler: Compiler;
    dashboard: Dashboard;
    dependencies: Dependencies;
    discovery: Discovery;
    disk: Disk;
    env: Env;
    extensions: Extensions;
    hooks: Hooks;
    logger: Logger;
    server: Server;
    store: Store;
    get services(): Container<Service>;
    set services(services: Container<Service>);
    get mode(): Mode;
    set mode(mode: Mode);
    get isProduction(): boolean;
    get isDevelopment(): boolean;
    constructor(config?: Store['repository']);
}
export { Framework };
//# sourceMappingURL=index.d.ts.map