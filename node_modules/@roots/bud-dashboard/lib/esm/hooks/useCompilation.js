import {useState, useEffect} from 'react'
import webpack from 'webpack'
/**
 * Use compilation
 */
export const useCompilation = app => {
  var _a, _b
  const [stats, setStats] = useState(
    (_b =
      (_a =
        app === null || app === void 0
          ? void 0
          : app.compiler) === null || _a === void 0
        ? void 0
        : _a.stats) === null || _b === void 0
      ? void 0
      : _b.json,
  )
  const [errors, setErrors] = useState(null)
  const [hasErrors, setHasErrors] = useState(false)
  const [warnings, setWarnings] = useState(null)
  const [hasWarnings, setHasWarnings] = useState(false)
  const [progress, setProgress] = useState(null)
  const [closed, setClosed] = useState(false)
  /**
   * Compilation callback
   * production mode callback takes two parameters (webpack err and stats)
   * however, the done hook used in development just takes one (stats)
   *
   * here we parse the callback args so that we dont have to
   * duplicate the callback.
   */
  const callback = (...args) => {
    const [err, stats] =
      args.length > 1 ? args : [null, args.pop()]
    app.when(err, () => console.error(err))
    const json =
      stats === null || stats === void 0
        ? void 0
        : stats.toJson(app.compiler.statsOptions)
    if (json) {
      setStats(json)
      setErrors(json.errors)
      setWarnings(json.errors)
      app
        .when(
          json === null || json === void 0
            ? void 0
            : json.hasErrors,
          () => setHasErrors(true),
          () => setErrors(null),
        )
        .when(
          json === null || json === void 0
            ? void 0
            : json.hasWarnings,
          () => setHasWarnings(true),
          () => setWarnings(null),
        )
    }
  }
  useEffect(() => {
    if (app.compiler.isCompiled) return
    app.compiler.compile(app.hooks.filter('after'))
    app.compiler.instance.hooks.done.tap(app.name, () =>
      app.compiler.instance.close(err => {
        err &&
          setErrors([
            ...(errors !== null && errors !== void 0
              ? errors
              : []),
            err,
          ])
        setClosed(true)
        app.isProduction && setTimeout(process.exit, 1000)
      }),
    )
    new webpack.ProgressPlugin((percentage, message) => {
      const decimal =
        percentage && typeof percentage === 'number'
          ? percentage
          : 0
      setProgress({
        decimal,
        percentage: `${Math.floor(decimal * 100)}%`,
        message,
      })
    }).apply(app.compiler.instance)
    app.when(
      !app.isDevelopment,
      () => {
        app.compiler.instance.run(callback)
      },
      ({server}) => {
        server.run(app.compiler.instance)
      },
    )
  })
  return {
    closed,
    progress,
    stats,
    errors,
    hasErrors,
    warnings,
    hasWarnings,
  }
}
//# sourceMappingURL=useCompilation.js.map
