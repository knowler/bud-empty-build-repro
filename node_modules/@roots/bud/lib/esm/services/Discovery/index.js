import {__decorate} from 'tslib'
import {Discovery as Base} from '@roots/bud-framework'
import {boundMethod as bind} from 'autobind-decorator'
import {cosmiconfigSync} from 'cosmiconfig'
import {readJsonSync} from 'fs-extra'
import resolvePkg from 'pkg-up'
import {dirname} from 'path'
export class Discovery extends Base {
  constructor() {
    super(...arguments)
    this.name = 'service/discovery'
  }
  register() {
    this.setStore(
      readJsonSync(this.app.path('project', 'package.json')),
    )
    this.discover('dependencies')
    this.discover('devDependencies')
    this.registerDiscovered()
    this.has('peers') &&
      this.getValues('peers').forEach(this.resolvePeers)
  }
  discover(type) {
    this.has(type) &&
      this.getEntries(type).map(([name, ver]) => {
        var _a
        if (
          !(name === null || name === void 0
            ? void 0
            : name.includes('bud')) &&
          !(name === null || name === void 0
            ? void 0
            : name.includes('sage'))
        )
          return
        const dir = dirname(
          resolvePkg.sync({cwd: dirname(require.resolve(name))}),
        )
        if (!dir) return
        this.set(
          `peers.${name}`,
          Object.assign(
            {name, ver, dir},
            this.mapConfig({name, dir}),
          ),
        )
        !((_a = this.resolveFrom) === null || _a === void 0
          ? void 0
          : _a.includes(dir)) && this.resolveFrom.push(dir)
      })
  }
  resolvePeers(pkg) {
    if (!pkg.peers) {
      return
    }
    pkg.peers.forEach(peer => {
      const dir = dirname(
        resolvePkg.sync({
          cwd: dirname(require.resolve(peer)),
        }),
      )
      if (!dir) return
      this.set(
        `peers.${peer}`,
        Object.assign(
          {name: peer, dir},
          this.mapConfig({name: peer, dir}),
        ),
      )
      !this.resolveFrom.includes(dir) &&
        this.resolveFrom.push(dir)
    })
  }
  registerDiscovered() {
    if (!this.app.store.isTrue('discover')) {
      return
    }
    this.each('peers', (_name, pkg) => {
      if (!pkg) return
      if (
        (pkg === null || pkg === void 0 ? void 0 : pkg.type) ===
          'extension' ||
        (pkg === null || pkg === void 0 ? void 0 : pkg.type) ===
          'preset'
      ) {
        this.app.extensions.add(require(pkg.name))
      }
    })
  }
  mapConfig(pkg) {
    var _a
    if (!pkg) return {}
    const cosmi = cosmiconfigSync(pkg.name, {
      searchPlaces: ['manifest.yml'],
    }).search(pkg.dir)
    return (
      cosmi === null || cosmi === void 0 ? void 0 : cosmi.config
    )
      ? Object.assign(Object.assign({}, cosmi.config), {
          type:
            (_a = cosmi.config.type) !== null && _a !== void 0
              ? _a
              : 'external',
          manifestPath: cosmi.filepath,
        })
      : {}
  }
  install() {
    this.each('peers', (name, peer) => {
      var _a, _b
      ;((_a =
        peer === null || peer === void 0
          ? void 0
          : peer.dependencies) === null || _a === void 0
        ? void 0
        : _a.production) &&
        this.app.dependencies.install(
          peer.dependencies.production,
        )
      ;((_b =
        peer === null || peer === void 0
          ? void 0
          : peer.dependencies) === null || _b === void 0
        ? void 0
        : _b.dev) &&
        this.app.dependencies.installDev(peer.dependencies.dev)
    })
  }
  getProjectInfo() {
    return this.all()
  }
}
__decorate([bind], Discovery.prototype, 'register', null)
__decorate([bind], Discovery.prototype, 'discover', null)
__decorate([bind], Discovery.prototype, 'resolvePeers', null)
__decorate(
  [bind],
  Discovery.prototype,
  'registerDiscovered',
  null,
)
__decorate([bind], Discovery.prototype, 'mapConfig', null)
__decorate([bind], Discovery.prototype, 'install', null)
__decorate([bind], Discovery.prototype, 'getProjectInfo', null)
//# sourceMappingURL=index.js.map
