'use strict'
Object.defineProperty(exports, '__esModule', {value: true})
exports.FileContainer = void 0
const tslib_1 = require('tslib')
const path_1 = tslib_1.__importDefault(require('path'))
const fs = tslib_1.__importStar(require('fs-extra'))
const resolve_from_1 = tslib_1.__importDefault(
  require('resolve-from'),
)
const lodash_1 = tslib_1.__importDefault(require('lodash'))
const globby_1 = require('globby')
const container_1 = require('@roots/container')
const autobind_decorator_1 = require('autobind-decorator')
class FileContainer extends container_1.Container {
  /**
   * Class constructor.
   */
  constructor(baseDir) {
    super()
    /**
     * FS-Extra library
     */
    this.fs = fs
    /**
     * PlatformPath
     */
    this.path = path_1.default
    /**
     * resolveFrom (better resolve)
     */
    this.from = resolve_from_1.default
    /**
     * Base directory
     */
    this._baseDir = process.cwd()
    this._baseDir = baseDir
  }
  /**
   * ## setBase
   *
   * Set the FS base directory.
   *
   * ### Usage
   *
   * ```
   * fsInstance.setBase(__dirname)
   * ```
   */
  set baseDir(dir) {
    this._baseDir = dir
  }
  /**
   * ## getBase
   *
   * Returns the FS base directory.
   *
   * ### Usage
   *
   * ```
   * fsInstance.getBase()
   * ```
   */
  get baseDir() {
    return this._baseDir
  }
  /**
   * ## setDisk
   *
   * Establish the disk repository from an array of globs.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.setDisk(['*.js', '!*.css.js'])
   * ```
   */
  setDisk(glob) {
    globby_1
      .sync(
        glob !== null && glob !== void 0
          ? glob
          : ['*', '**/*', '!vendor', '!node_modules'],
        {
          onlyFiles: false,
          cwd: this._baseDir,
          expandDirectories: true,
        },
      )
      .map(file => {
        this.set(file, path_1.default.join(this.baseDir, file))
      })
    return this
  }
  /**
   * ## fs.ls
   *
   * List repository contents.
   *
   * ### Usage
   *
   */
  ls(key) {
    return key
      ? lodash_1.default.get(this.repository, key)
      : this.repository
  }
  /**
   * ## has
   *
   * Return boolean `true` if key is a match.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.has('some/file.js')
   * ```
   */
  has(key) {
    return lodash_1.default.has(this.repository, key)
  }
  /**
   * ## set
   *
   * Set a value.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.set('some/file.js', '/absolute/path/to/some/file.js')
   * ```
   */
  set(key, value) {
    lodash_1.default.set(this.repository, [`${key}`], value)
    return this
  }
  /**
   * ## exists
   *
   * Return a boolean `true` if repository has a key and it's value
   * resolves to an actual disk location.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.exists('some/file.js')
   * ```
   */
  exists(key) {
    return this.fs.existsSync(this.get(key))
  }
  /**
   * ## ensure
   *
   * Create a file if it does not already exist. Will also create an
   * associated repository entry if it doesn't exist.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.ensure('some/file.js')
   * ```
   */
  ensure(key) {
    const file = this.has(key)
      ? this.get(key)
      : this.path.resolve(this.baseDir, key)
    this.fs.ensureFileSync(file)
    this.set(key, file)
  }
  /**
   * ## ensureDir
   *
   * Create a directory if it does not already exist. Will also create an
   * associated repository entry if it doesn't exist.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.ensureDir('some/file.js')
   * ```
   */
  ensureDir(key) {
    const dir = this.has(key)
      ? this.get(key)
      : this.path.resolve(this.baseDir, key)
    this.fs.ensureDirSync(dir)
    this.set(key, dir)
  }
  /**
   * ## read
   *
   * Read file contents as a utf8 encoded string.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.read('some/file.md')
   * ```
   */
  read(key) {
    return this.fs.readFileSync(this.get(key), 'utf8')
  }
  /**
   * ## readJson
   *
   * Retrieve file contents as a javascript object.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.readJson('some/file.json')
   * // => {json: 'contents', as: 'an object'}
   * ```
   */
  readJson(key) {
    return this.fs.readJsonSync(this.get(key))
  }
  /**
   * ## write
   *
   * Write file contents as a string
   *
   * ### Usage
   *
   * ```js
   * fsInstance.write('some/file.md', 'string contens')
   * ```
   */
  write(key, content) {
    const file = this.has(key)
      ? this.get(key)
      : this.path.resolve(this.baseDir, key)
    this.fs.writeFileSync(file, content)
    this.set(key, file)
  }
  /**
   * ## writeJson
   *
   * Write file contents as a JSON object.
   *
   * ### Usage
   *
   * ```js
   * fsInstance.writeJson(
   *   'some/file.json',
   *   {json: 'file contents'},
   * )
   * ```
   */
  writeJson(key, content) {
    const file = this.has(key)
      ? this.get(key)
      : this.path.resolve(this.baseDir, key)
    this.fs.writeJsonSync(file, content)
    this.set(key, file)
  }
  /**
   * ## require
   *
   * NodeRequire a matching file as a module
   *
   * ### Usage
   *
   * ```js
   * fsInstance.require('path/to/module.js')
   * ```
   */
  require(key) {
    return require(this.get(key))
  }
}
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'setDisk',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'ls',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'has',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'set',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'exists',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'ensure',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'ensureDir',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'read',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'readJson',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'write',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'writeJson',
  null,
)
tslib_1.__decorate(
  [autobind_decorator_1.boundMethod],
  FileContainer.prototype,
  'require',
  null,
)
exports.FileContainer = FileContainer
//# sourceMappingURL=index.js.map
